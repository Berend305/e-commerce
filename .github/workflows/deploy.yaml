name: CI/CD Pipeline with Trivy and ELK Integration

on:
  push:
    branches: [ "main" ]

jobs:
  build-and-deploy:
    runs-on: self-hosted

    steps:
    # Stap 1: Haal de code op uit je repository
    - name: Checkout code
      uses: actions/checkout@v3

    # Stap 2: Set up PHP
    - name: Set up PHP
      uses: shivammathur/setup-php@v2
      with:
        php-version: '8.3'
        ini-file: production
        tools: composer

    # Stap 3: Installeer Composer dependencies
    - name: Install Dependencies
      run: composer install --no-progress --prefer-dist

    # Stap 4: Cleanup bestaande resources in Kubernetes
    - name: Cleanup Existing Resources
      run: |
        kubectl delete deployment ecommerce-web --ignore-not-found
        kubectl delete deployment ecommerce-db --ignore-not-found
        kubectl delete deployment phpmyadmin --ignore-not-found
        kubectl delete service ecommerce-web-service --ignore-not-found
        kubectl delete service ecommerce-db --ignore-not-found
        kubectl delete service phpmyadmin-service --ignore-not-found

    # Stap 5: Build en Push Docker Image naar Docker Hub
    - name: Build en Push Docker Image
      env:
        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      run: |
        docker build -t $DOCKER_USERNAME/ecommerce-web:latest ./web
        echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin
        docker push $DOCKER_USERNAME/ecommerce-web:latest

    # Stap 6: Scan Docker Image for Vulnerabilities with Trivy
    - name: Scan Docker Image for Vulnerabilities
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ secrets.DOCKER_USERNAME }}/ecommerce-web:latest
        format: 'table'
        vuln-type: 'os,library'
        severity: 'CRITICAL,HIGH'
      continue-on-error: true

    # Stap 7: Configure Kubernetes Context
    - name: Configure Kubernetes Context
      env:
        KUBECONFIG_CONTENT: ${{ secrets.KUBECONFIG_CONTENT }}
      run: |
        mkdir -p $HOME/.kube
        echo "$KUBECONFIG_CONTENT" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config

    # Stap 8: Deploy naar k3s Cluster
    - name: Deploy to k3s Cluster
      run: |
        kubectl apply -f k3s/secrets.yaml
        kubectl apply -f k3s/web-deployment.yaml
        kubectl apply -f k3s/db-deployment.yaml
        kubectl apply -f k3s/phpmyadmin-deployment.yaml

    # Stap 9: Wachten tot alle pods klaar zijn
    - name: Wait for Pods
      run: |
        kubectl wait --for=condition=ready pod -l app=ecommerce --timeout=300s
        kubectl wait --for=condition=ready pod -l app=ecommerce-db --timeout=300s

    # Stap 10: Test Database Connectiviteit
    - name: Test Database Connectivity
      run: |
        kubectl run test-db-connectivity --rm -i --restart=Never --image=mysql:5.7 \
          --command -- bash -c 'mysql -h ecommerce-db -u root -pecommerce_password -e "SHOW DATABASES;"'

    # Stap 11: Haal Node IP op en stel omgevingsvariabelen in
    - name: Fetch Node IP
      id: get-node-ip
      run: |
        NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
        echo "NODE_IP=$NODE_IP" >> $GITHUB_ENV

    # Stap 12: Unit Tests uitvoeren
    - name: Run Unit Tests
      env:
        WEB_SERVER_URL: http://${{ env.NODE_IP }}:30080
      run: vendor/bin/phpunit --testdox tests/

    # Stap 13: OWASP Dependency Check
    - name: OWASP Dependency Check
      uses: dependency-check/scan-action@v2
      with:
        project: "E-commerce"
        format: "HTML"
        outputDirectory: "owasp-report"
      continue-on-error: true

    # Stap 14: Upload OWASP Dependency Report
    - name: Upload Dependency Report
      uses: actions/upload-artifact@v3
      with:
        name: owasp-dependency-report
        path: owasp-report/dependency-check-report.html

    # Stap 15: Verifieer Vulnerability Reports
    - name: Verify Vulnerability Reports
      run: |
        kubectl get vulnerabilityreports -A
        for report in $(kubectl get vulnerabilityreports -A -o jsonpath='{.items[*].metadata.name}'); do
          echo "Describing report: $report"
          kubectl describe vulnerabilityreports $report -n default
        done

    # Stap 16: Verbind met ELK Stack
    - name: Send Logs to ELK
      run: |
        echo "Stuur Trivy-scan logs naar ELK..."
        curl -XPOST -H "Content-Type: application/json" \
          -d '{"log": "Trivy Scan Result", "details": "$(cat trivy-output.json)"}' \
          http://elk-stack-ip:9200/trivy-logs/_doc/

    # Stap 17: Controleer Kubernetes Resources
    - name: Verify Kubernetes Resources
      run: |
        kubectl get pods -o wide
        kubectl get services -o wide
